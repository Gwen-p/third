<script>    import { getContext } from 'svelte'; // import Svelte helper to read context values    import { API_BASE } from '../config.js'; // import API base URL from config    const currentUser = getContext('currentUser'); // read 'currentUser' from Svelte context (likely a store or value)    let polls = []; // reactive array to hold polls retrieved from the backend    let selections = {}; // object that maps pollId -> selected option index (0-based) for UI state    let isLoading = false; // boolean flag used to indicate an ongoing action (vote/delete)    let loadingPolls = false; // boolean flag used while fetching all polls    async function fetchPolls() { // function to fetch all polls from API        loadingPolls = true; // set flag to indicate polls are being loaded        try {            const response = await fetch(`${API_BASE}/polls`); // send GET request to /polls            if (response.ok) { // if server responded with 200-299                selections = {};                polls = await response.json(); // parse response JSON and assign to polls            }        } finally {            loadingPolls = false; // always clear the loading flag when finished or when error happens        }    }    async function vote(pollId, optionIndex) { // function to submit a vote; optionIndex is expected as 1-based here        isLoading = true; // set global action-loading flag to true        try {            const isUnknown = $currentUser === 'unknown'; // check whether current user is 'unknown' (anonymous)            let response; // variable to hold fetch response            if (isUnknown) { // anonymous user path                response = await fetch(`${API_BASE}/votes/${pollId}/${optionIndex}`, {                    method: 'POST' // POST to anonymous vote endpoint                });            } else { // registered user path                response = await fetch(`${API_BASE}/votes/${pollId}/${optionIndex}/${$currentUser}`, {                    method: 'POST' // POST to vote endpoint that records the user                });            }            if (response.ok) { // if vote succeeded                await fetchPolls(); // refresh polls to show updated counts                if (!isUnknown) { // store selection locally only for registered users                    selections[pollId] = optionIndex - 1; // convert 1-based optionIndex to 0-based index for the UI                }            } else { // if server returned an error status                const error = await response.json(); // try to parse the error response body                alert(error.status + ' Error while voting'); // show an alert with server message or generic text            }        } catch (err) { // network or unexpected error            console.error('Network error voting:', err); // log the error for debugging            alert('Network error. Please try again.'); // notify the user        } finally {            isLoading = false; // always clear the action-loading flag        }    }    async function deletePoll(pollId) { // function to delete a poll (should be allowed only for its creator)        if (!confirm('¿Eliminar encuesta?')) return; // ask the user to confirm deletion, bail out if cancelled        isLoading = true; // set loading flag while deletion is in progress        try {            const response = await fetch(`${API_BASE}/polls/${pollId}`, {                method: 'DELETE' // DELETE request to /polls/:id endpoint            });            if (response.ok) { // if deletion succeeded                polls = polls.filter(p => p.id !== pollId); // remove the deleted poll from local array                delete selections[pollId]; // remove any stored selection for that poll in local state            } else { // if deletion failed on the server                const error = await response.json(); // parse error response                alert(error.status + ' Failed to delete poll'); // show an alert with error information            }        } catch (err) { // network or unexpected error            console.error('Network error deleting poll:', err); // log it for debugging            alert('Network error. Please try again.'); // notify the user        } finally {            isLoading = false; // clear the loading flag        }    }    function getVoteCount(option) { // helper that returns the number of votes for a single option        return option.votes ? option.votes.length : 0; // if `votes` exists return its length, otherwise return 0    }    function isPollCreator(poll) { // helper that checks if current user is the poll's creator        return $currentUser !== 'unknown' && poll.creator === $currentUser; // unknown can't be a creator; otherwise compare creator field    }    async function hasUserVoted(pollId) {        if ($currentUser === 'unknown') return false;        try {            const response = await fetch(`${API_BASE}/votes/${pollId}`, {                method: 'GET'            });            if (response.ok) {                const votes = await response.json();                return votes?.some(v => v.user === $currentUser) || false;            } else { // if deletion failed on the server                const error = await response.json(); // parse error response                alert(error.status + ' Failed to delete poll'); // show an alert with error information            }        } catch (error) {            console.error('Error checking vote:', error);            return false;        }    }    // helper that returns the caption of the option the current user voted for, or null    async function getUserVote(pollId) {        if ($currentUser === 'unknown') return null;        try {            const response = await fetch(`${API_BASE}/votes/${pollId}`, {                method: 'GET' // DELETE request to /polls/:id endpoint            });            if (response.ok) {                const votes = await response.json();                // Encontrar el voto específico del usuario actual                const userVote = votes.find(v => v.user.name === $currentUser);                // Devolver el caption de la opción votada o null                return userVote ? userVote.optionCaption : null;            } else {                const error = await response.json();                alert(error.status + ' Failed to fetch user vote');                return null;            }        } catch (error) {            console.error('Error fetching user vote:', error);            return null;        }    /*    if ($currentUser === 'unknown') return null; // anonymous users have no tracked vote        for (const option of poll.options) { // iterate options to find the one containing the user's vote            if (option.votes?.some(vote => vote?.user === $currentUser)) {                return option.caption; // return the matching option caption            }        }        return null; // if no vote found for this user return null    */    }    fetchPolls(); // initial call to load polls when component is mounted</script><div class="component">    <h2>Vote on Polls</h2>    {#if loadingPolls}        <p>Loading polls...</p>    {:else if polls.length === 0}        <p>No polls available. Create some polls first!</p>    {:else}        {#each polls as poll (poll.id)}            <div class="poll">                <h3>{poll.question}</h3> <!-- display the poll question -->                {#if isPollCreator(poll)} <!-- if current user created this poll -->                    <button on:click={() => deletePoll(poll.id)} disabled={isLoading}>                        {isLoading ? 'Deleting...' : 'Delete Poll'}                    </button> <!-- show delete button and disable it while an action is in progress -->                {/if}                <div class="poll-meta"> <!-- metadata area for the poll -->                    <span class="creator">By: {poll.creator}</span> <!-- display poll creator -->                </div>                {#each poll.options as option, index (index)} <!-- iterate over options for this poll -->                    <div class="option"> <!-- container for one option -->                        <label>                            <input                                    type="radio"                                    name={`poll-${poll.id}`}                                    value={index}                                    checked={selections[poll.id] === index}                                    on:click={() => vote(poll.id, index + 1)}                                    disabled={isLoading}                            />                            {option.caption} <!-- show option text -->                        </label>                        <span class="vote-count">({getVoteCount(option)} votes)</span> <!-- show number of votes for this option -->                        {#if option.votes && option.votes.length > 0} <!-- if this option has vote entries -->                            <div class="vote-timeline"> <!-- optional timeline / list of votes -->                                {#each option.votes as voteObj, i (i)} <!-- iterate votes; voteObj may be null-or-object -->                                    <span class="vote-time">                                        <!-- show time if voteObj contains a timestamp property, otherwise try to format raw value -->                                        {#if typeof voteObj === 'object' && voteObj?.time}                                            {new Date(voteObj.time).toLocaleTimeString()}                                        {:else}                                            {new Date(voteObj).toLocaleTimeString()}                                        {/if}                                    </span>                                {/each}                            </div>                        {/if}                    </div>                {/each}                {#if $currentUser !== 'unknown' && hasUserVoted(poll.id)} <!-- if a registered user and they have voted -->                    <p>Your vote: {getUserVote(poll.id)}</p> <!-- show the option caption they voted for -->                    <small>You can change it by selecting another option.</small> <!-- hint that they can modify their vote -->                {/if}                {#if $currentUser === 'unknown'} <!-- if the viewer is anonymous -->                    <p><em>Unknown user: you can vote multiple times.</em></p> <!-- explain unlimited voting for unknown -->                {/if}                <div class="total-votes"> <!-- display total votes for this poll -->                    Total votes: {poll.options.reduce((t, o) => t + getVoteCount(o), 0)}                </div>            </div>        {/each}    {/if}</div>